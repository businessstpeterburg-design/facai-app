<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>TON Temple • Pure Code Universe</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #ui { position: absolute; bottom: 20px; width: 100%; text-align: center; font-family: sans-serif; }
        .btn { padding: 15px 40px; background: rgba(212,175,55,0.2); border: 1px solid #d4af37; color: #ffec8b; border-radius: 30px; cursor: pointer; backdrop-filter: blur(5px); text-transform: uppercase; letter-spacing: 2px; transition: 0.3s; }
        .btn:hover { background: rgba(212,175,55,0.5); box-shadow: 0 0 20px #d4af37; }
    </style>
</head>
<body>
    <div id="ui"><button class="btn" onclick="startAnim()">Активировать Вселенную</button></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer, eye, dragonParts = [], stones = [];
        let clock = new THREE.Clock();
        let isLooking = false;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 1. ПРОЦЕДУРНЫЙ ГЛАЗ (ШЕЙДЕРНЫЙ ФОН)
            const eyeGeo = new THREE.PlaneGeometry(100, 100);
            const eyeMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform float time;
                    void main() {
                        vec2 uv = vUv - 0.5;
                        float dist = length(uv);
                        // Создаем радужку
                        float iris = smoothstep(0.4, 0.1, dist) * smoothstep(0.05, 0.15, dist);
                        vec3 color = vec3(0.1, 0.4, 0.8) * iris; // Синий
                        color += vec3(0.8, 0.5, 0.1) * (1.0 - smoothstep(0.1, 0.4, dist)) * 0.3; // Золотой отблеск
                        // Пульсация зрачка
                        float pupil = smoothstep(0.08 + sin(time*2.0)*0.01, 0.07, dist);
                        color = mix(color, vec3(0.0), pupil);
                        // Звездная пыль
                        float stars = pow(fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453), 20.0);
                        gl_FragColor = vec4(color + stars * iris, 1.0);
                    }
                `,
                transparent: true
            });
            const bg = new THREE.Mesh(eyeGeo, eyeMat);
            bg.position.z = -10;
            scene.add(bg);
            eye = bg;

            // 2. ЗОЛОТОЙ ПРОЦЕДУРНЫЙ ДРАКОН (ИЗ СФЕР)
            const dragonGroup = new THREE.Group();
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.1, emissive: 0x554400 });
            
            for(let i = 0; i < 40; i++) {
                const segGeo = new THREE.SphereGeometry(0.5 - (i*0.01), 12, 12);
                const seg = new THREE.Mesh(segGeo, goldMat);
                dragonParts.push(seg);
                dragonGroup.add(seg);
            }
            scene.add(dragonGroup);

            // 3. ХАОТИЧНЫЕ МЕТЕОРИТЫ
            for(let i = 0; i < 30; i++) {
                const sGeo = new THREE.DodecahedronGeometry(Math.random() * 0.8, 0);
                const stone = new THREE.Mesh(sGeo, goldMat);
                stone.position.set((Math.random()-0.5)*50, (Math.random()-0.5)*40, (Math.random()-0.5)*30);
                stone.userData.speed = Math.random() * 0.01;
                scene.add(stone);
                stones.push(stone);
            }

            const light = new THREE.PointLight(0xffffff, 2, 100);
            light.position.set(0, 0, 10);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x444444));

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            let t = clock.getElapsedTime();
            
            eye.material.uniforms.time.value = t;

            // Движение дракона
            dragonParts.forEach((p, i) => {
                let wave = Math.sin(t * 2 - i * 0.2);
                let cosWave = Math.cos(t * 1.5 - i * 0.2);
                
                if (!isLooking) {
                    // Извивается в полете
                    p.position.set(Math.sin(t)*10 + wave, Math.cos(t*0.5)*5 + cosWave, 10 - i*0.8);
                } else {
                    // Замирает и плавно покачивается перед камерой
                    p.position.set(wave * 0.2, cosWave * 0.2 + 2, 15 - i*0.8);
                    p.lookAt(camera.position);
                }
            });

            // Метеориты
            stones.forEach(s => {
                s.rotation.x += 0.01;
                s.position.y += Math.sin(t + s.position.x) * 0.005;
            });

            renderer.render(scene, camera);
        }

        function startAnim() {
            isLooking = !isLooking;
            const btn = document.querySelector('.btn');
            btn.innerText = isLooking ? "В движении" : "Замереть";
        }

        init();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
