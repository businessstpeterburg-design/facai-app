<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"/>
  <title>TON TEMPLE — Fa Cai Ritual</title>

  <style>
    :root{
      --bg0:#020203;
      --bg1:#07080b;
      --gold:#FFD36A;
      --gold2:#B8860B;
      --warm:#FFF3D1;
      --crimson:#B8001D;
      --glass: rgba(10,10,12,.52);
      --glassBorder: rgba(255,211,106,.18);
    }
    *{box-sizing:border-box;}
    html,body{height:100%; margin:0; background:#000; overflow:hidden; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{touch-action:none; -webkit-user-select:none; user-select:none;}

    /* ===== FULLSCREEN 3D ===== */
    #stage3d{position:fixed; inset:0; width:100%; height:100%; z-index:1; background: radial-gradient(1200px 800px at 50% 25%, #101224 0%, #07080b 55%, #000 100%);}
    #fx2d{position:fixed; inset:0; width:100%; height:100%; z-index:3; pointer-events:none;}

    /* ===== UI LAYER ===== */
    #ui{position:fixed; inset:0; z-index:6; display:flex; justify-content:center; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);}
    .uiWrap{width:min(980px, 100%); height:100%; padding:10px; display:flex; flex-direction:column; gap:10px;}

    .topHud{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px; border-radius:18px;
      background: linear-gradient(180deg, rgba(10,10,12,.62), rgba(10,10,12,.35));
      border:1px solid var(--glassBorder);
      backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
    }
    .brand{display:flex; flex-direction:column; gap:2px; line-height:1.1;}
    .brand .t1{font-weight:700; letter-spacing:.12em; font-size:12px; color:var(--warm); text-transform:uppercase;}
    .brand .t2{font-weight:600; letter-spacing:.16em; font-size:10px; color:rgba(255,211,106,.8); text-transform:uppercase;}

    .hudRight{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:8px 10px; border-radius:999px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,211,106,.14);
      color: rgba(255,243,209,.92);
      font-size:11px; letter-spacing:.12em; text-transform:uppercase; white-space:nowrap;
    }
    .btn{
      cursor:pointer; border:none; outline:none;
      padding:9px 12px; border-radius:999px;
      background: rgba(255,211,106,.10);
      border:1px solid rgba(255,211,106,.25);
      color: rgba(255,243,209,.95);
      font-size:11px; letter-spacing:.14em; text-transform:uppercase;
      transition: transform .12s ease, background .18s ease, border-color .18s ease;
    }
    .btn:active{ transform: scale(.99); }
    .btnSmall{padding:9px 10px; min-width:44px; text-align:center;}

    /* Center card - mobile first */
    .center{flex:1; display:flex; align-items:center; justify-content:center; padding:8px 0;}
    .card{
      width:min(680px, 100%);
      border-radius:20px;
      background: rgba(10,10,12,.45);
      border:1px solid rgba(255,211,106,.14);
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 14px 55px rgba(0,0,0,.42);
      overflow:hidden;
      padding:14px;
    }
    .titleRow{display:flex; align-items:flex-end; justify-content:space-between; gap:10px; margin-bottom:12px;}
    .titleRow h2{
      margin:0; font-size:13px; letter-spacing:.16em; text-transform:uppercase;
      color:rgba(255,243,209,.95); font-weight:800;
    }
    .titleRow .sub{font-size:10px; letter-spacing:.12em; color: rgba(255,211,106,.74); text-transform:uppercase;}

    .bigAction{display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center;}
    .wheelBtn{
      width:min(360px, 92%);
      height:58px;
      border-radius:16px;
      border:1px solid rgba(255,211,106,.28);
      background: linear-gradient(180deg, rgba(255,211,106,.18), rgba(255,211,106,.08));
      color: rgba(255,243,209,.98);
      font-size:12px; letter-spacing:.22em; text-transform:uppercase; font-weight:800;
      box-shadow: 0 16px 50px rgba(0,0,0,.35);
      cursor:pointer;
    }
    .micro{font-size:10px; letter-spacing:.12em; color: rgba(255,243,209,.75); text-align:center; line-height:1.4; max-width: 520px;}

    .dock{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px; border-radius:18px;
      background: linear-gradient(180deg, rgba(10,10,12,.54), rgba(10,10,12,.32));
      border:1px solid rgba(255,211,106,.14);
      backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px);
    }
    .dockLeft, .dockRight{display:flex; gap:8px; align-items:center;}
    .dotBtn{
      width:44px; height:44px; border-radius:16px;
      border:1px solid rgba(255,211,106,.18);
      background: rgba(0,0,0,.22);
      color: rgba(255,243,209,.92);
      cursor:pointer;
    }

    /* ===== OVERLAY PARCHMENT ===== */
    #overlay{position:fixed; inset:0; z-index:20; display:none; align-items:center; justify-content:center; padding: env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px; background: rgba(0,0,0,.70); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);}
    #overlay.show{display:flex;}
    .parchmentWrap{
      width:min(820px, 96vw);
      height:min(78vh, 720px);
      position:relative;
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 25px 120px rgba(0,0,0,.65);
      border:1px solid rgba(255,211,106,.22);
      background: linear-gradient(180deg, rgba(20,16,10,.95), rgba(10,9,8,.86));
    }
    .overlayTop{
      position:absolute; left:0; right:0; top:0;
      display:flex; justify-content:space-between; align-items:center;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.0));
      z-index:2;
    }
    .overlayTop .label{font-size:10px; letter-spacing:.18em; text-transform:uppercase; color: rgba(255,243,209,.85); font-weight:800;}
    .closeBtn{
      cursor:pointer; border:none;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,211,106,.10);
      border:1px solid rgba(255,211,106,.22);
      color: rgba(255,243,209,.95);
      font-size:10px; letter-spacing:.18em; text-transform:uppercase;
    }
    #paper{position:absolute; inset:0; width:100%; height:100%;}

    /* ===== ERROR HUD (если что-то падает — увидишь на телефоне) ===== */
    #errHud{
      position:fixed; left:10px; right:10px; bottom:10px; z-index:9999;
      display:none;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,.75);
      border:1px solid rgba(255,211,106,.22);
      color: rgba(255,243,209,.92);
      font-size:11px;
      line-height:1.35;
      white-space:pre-wrap;
      max-height:40vh;
      overflow:auto;
    }

    /* Mobile tweaks */
    @media (max-width:520px){
      .uiWrap{padding:8px; gap:8px;}
      .topHud{padding:10px 10px;}
      .hudRight{gap:6px;}
      .pill{font-size:10px; padding:7px 9px;}
      .btn{font-size:10px; padding:8px 10px;}
      .card{padding:12px;}
    }
  </style>
</head>

<body>
  <canvas id="stage3d"></canvas>
  <canvas id="fx2d"></canvas>

  <div id="ui">
    <div class="uiWrap">
      <div class="topHud">
        <div class="brand">
          <div class="t1">TON TEMPLE</div>
          <div class="t2">帝王福流仪式</div>
        </div>

        <div class="hudRight">
          <div class="pill" id="qkPill">QK 0.00</div>
          <div class="pill" id="flowPill">FLOW 50/100</div>
          <button class="btn btnSmall" id="helpBtn">i</button>
          <button class="btn btnSmall" id="langBtn">EN</button>
          <button class="btn" id="gateBtn">GATE</button>
        </div>
      </div>

      <div class="center">
        <div class="card">
          <div class="titleRow">
            <h2 id="titleMain">Temple Ritual</h2>
            <div class="sub" id="titleSub">Spin → Guidance → Decision</div>
          </div>
          <div class="bigAction">
            <button class="wheelBtn" id="spinBtn">SPIN WHEEL</button>
            <div class="micro" id="microText">This is a ritualized interface. Not financial advice.</div>
          </div>
        </div>
      </div>

      <div class="dock">
        <div class="dockLeft">
          <button class="dotBtn" id="journalBtn">J</button>
          <button class="dotBtn" id="proBtn">P</button>
        </div>
        <div class="dockRight">
          <button class="dotBtn" id="soundBtn">S</button>
          <button class="dotBtn" id="wishBtn">★</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Parchment overlay -->
  <div id="overlay">
    <div class="parchmentWrap">
      <div class="overlayTop">
        <div class="label" id="overlayLabel">TEMPLE GUIDANCE</div>
        <button class="closeBtn" id="closeOverlay">CLOSE</button>
      </div>
      <canvas id="paper"></canvas>
    </div>
  </div>

  <div id="errHud"></div>

  <!-- Three.js (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (function(){
    /* =======================
       0) ERROR HUD
    ======================= */
    const errHud = document.getElementById('errHud');
    function showErr(msg){
      errHud.style.display = 'block';
      errHud.textContent = msg;
    }
    window.addEventListener('error', (e)=>{
      showErr('JS ERROR:\\n' + (e?.message || e) + '\\n' + (e?.filename||'') + ':' + (e?.lineno||'') );
    });
    window.addEventListener('unhandledrejection', (e)=>{
      showErr('PROMISE ERROR:\\n' + (e?.reason?.message || e?.reason || e));
    });

    /* =======================
       1) PERF + DPR
    ======================= */
    const PERF = (function(){
      let quality = 'high';
      const mem = navigator.deviceMemory || 4;
      const cores = navigator.hardwareConcurrency || 4;
      if(mem <= 3 || cores <= 4) quality = 'med';
      if(mem <= 2) quality = 'low';
      function dprCap(){
        const max = (quality==='low') ? 1.25 : (quality==='med' ? 1.6 : 2.0);
        return Math.min(window.devicePixelRatio || 1, max);
      }
      return {quality, dprCap};
    })();

    /* =======================
       2) I18N (EN label locked)
    ======================= */
    const I18N = (function(){
      const key = 'tt_lang_v2';
      let lang = localStorage.getItem(key) || 'zh';
      const dict = {
        zh:{
          titleMain:'帝王福流仪式',
          titleSub:'转轮 → 指引 → 抉择',
          spin:'转动福轮',
          micro:'这是一种仪式化界面，并非金融建议。',
          overlay:'天宫指引',
          gate:'供奉',
          wish:'许一个愿',
          info:'说明',
        },
        en:{
          titleMain:'Temple Ritual',
          titleSub:'Spin → Guidance → Decision',
          spin:'SPIN WHEEL',
          micro:'This is a ritualized interface. Not financial advice.',
          overlay:'TEMPLE GUIDANCE',
          gate:'GATE',
          wish:'MAKE A WISH',
          info:'INFO',
        }
      };
      function set(newLang){
        lang = (newLang==='en') ? 'en' : 'zh';
        localStorage.setItem(key, lang);
        render();
      }
      function toggle(){ set(lang==='zh' ? 'en' : 'zh'); }
      function t(k){ return (dict[lang] && dict[lang][k]) ? dict[lang][k] : k; }
      function render(){
        document.documentElement.lang = lang;
        document.getElementById('titleMain').textContent = t('titleMain');
        document.getElementById('titleSub').textContent = t('titleSub');
        document.getElementById('spinBtn').textContent = t('spin');
        document.getElementById('microText').textContent = t('micro');
        document.getElementById('overlayLabel').textContent = t('overlay');
        document.getElementById('gateBtn').textContent = (lang==='zh') ? '供奉' : 'GATE';
        document.getElementById('helpBtn').textContent = 'i';
        document.getElementById('langBtn').textContent = 'EN'; // locked
      }
      render();
      return {get:()=>lang, toggle, t, render};
    })();

    /* =======================
       3) STATE (QK, Flow, Premium, No-repeat predictions)
    ======================= */
    const State = (function(){
      const key='tt_state_v2';
      const base={qk:0, flow:50, premiumUntil:0, lastSpinDay:'', bag:[], usedCount:0};
      function load(){
        try{ return Object.assign({}, base, JSON.parse(localStorage.getItem(key)||'{}')); }
        catch(e){ return Object.assign({}, base); }
      }
      let s = load();
      function save(){ localStorage.setItem(key, JSON.stringify(s)); }
      function todayKey(){
        const d=new Date();
        return d.getFullYear()+'-'+(d.getMonth()+1)+'-'+d.getDate();
      }
      function spunToday(){ return s.lastSpinDay === todayKey(); }
      function markSpin(){ s.lastSpinDay = todayKey(); save(); }
      function addQK(v){ s.qk = Math.max(0, Math.round((s.qk+v)*100)/100); save(); }
      function setFlow(v){ s.flow = Math.max(0, Math.min(100, Math.round(v))); save(); }
      function premiumOn(){ return s.premiumUntil > Date.now(); }
      function addPremium(hours){ s.premiumUntil = Date.now() + hours*3600*1000; save(); }
      function ensureBag(total){
        if(!Array.isArray(s.bag) || s.bag.length===0){
          const ids=[...Array(total)].map((_,i)=>i);
          for(let i=ids.length-1;i>0;i--){
            const j=(Math.random()*(i+1))|0; const t=ids[i]; ids[i]=ids[j]; ids[j]=t;
          }
          s.bag = ids;
          save();
        }
      }
      function nextId(total){
        ensureBag(total);
        const id = s.bag.pop();
        s.usedCount = (s.usedCount||0)+1;
        save();
        return id;
      }
      function get(){ return s; }
      return {get, save, addQK, setFlow, spunToday, markSpin, premiumOn, addPremium, nextId};
    })();

    function renderHUD(){
      const s=State.get();
      document.getElementById('qkPill').textContent = 'QK ' + s.qk.toFixed(2);
      document.getElementById('flowPill').textContent = 'FLOW ' + String(s.flow).padStart(2,'0') + '/100';
    }
    renderHUD();

    /* =======================
       4) AUDIO (light, Telegram-safe)
    ======================= */
    const AudioX = (function(){
      let ctx=null, master=null; let enabled=true;
      function init(){
        if(ctx) return;
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        master = ctx.createGain();
        master.gain.value = 0.65;
        master.connect(ctx.destination);
      }
      function ensure(){
        if(!enabled) return;
        init();
        if(ctx && ctx.state!=='running') ctx.resume().catch(()=>{});
      }
      function tone(freq, dur, vol, type){
        ensure(); if(!ctx) return;
        const t0=ctx.currentTime;
        const o=ctx.createOscillator();
        const g=ctx.createGain();
        o.type=type||'sine';
        o.frequency.setValueAtTime(freq, t0);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(vol||0.12, t0+0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0+(dur||0.25));
        o.connect(g).connect(master);
        o.start(t0);
        o.stop(t0+(dur||0.25)+0.02);
      }
      function whoosh(){ tone(180, 0.22, 0.10, 'triangle'); }
      function chime(){ tone(523.25,0.22,0.12,'sine'); setTimeout(()=>tone(659.25,0.22,0.10,'sine'),60); setTimeout(()=>tone(783.99,0.30,0.08,'sine'),120); }
      function stamp(){ tone(110,0.16,0.18,'sine'); setTimeout(()=>tone(55,0.12,0.14,'sine'),35); }
      function tick(){ tone(420,0.08,0.05,'triangle'); }
      function toggle(){
        enabled=!enabled;
        if(master) master.gain.value = enabled ? 0.65 : 0.0001;
        return enabled;
      }
      return {ensure, whoosh, chime, stamp, tick, toggle};
    })();

    function haptic(){
      try{
        if(window.Telegram?.WebApp?.HapticFeedback){
          window.Telegram.WebApp.HapticFeedback.impactOccurred('light');
          return;
        }
      }catch(e){}
      if(navigator.vibrate) navigator.vibrate(10);
    }

    /* =======================
       5) PREDICTIONS (100 EN + 100 ZH, 5+ sentences)
    ======================= */
    function buildPredictions(){
      // Шаблонный генератор: чтобы не вставлять сюда 200 огромных текстов руками.
      // Но итог всё равно = 100 уникальных EN + 100 уникальных ZH.
      const enThemes = [
        ['family','rest','calm','one task','walk'],
        ['focus','simplicity','boundaries','health','sleep'],
        ['gratitude','kindness','patience','silence','order'],
        ['courage','gentle confidence','small steps','clarity','balance'],
        ['new experience','curiosity','friends','lightness','joy'],
        ['discipline','slow down','no rush','breathe','protect energy'],
        ['reflection','avoid drama','soft words','grounding','tea'],
        ['decision','postpone big moves','observe','choose safe','steady'],
        ['harmony','no conflict','listen','forgive','reset'],
        ['flow','notice small luck','be present','reduce noise','finish']
      ];
      const zhThemes = [
        ['家人','休息','平静','一件小事','散步'],
        ['专注','简单','边界','健康','睡眠'],
        ['感恩','善意','耐心','安静','秩序'],
        ['勇气','温柔自信','小步','清晰','平衡'],
        ['新体验','好奇','朋友','轻松','喜悦'],
        ['自律','放慢','不着急','呼吸','护能量'],
        ['反思','远离纷争','温和表达','落地','热茶'],
        ['决定','大事延后','观察','选稳妥','稳定'],
        ['和谐','不对抗','倾听','放下','重启'],
        ['福流','留心小运','当下','降噪','完成']
      ];

      function enText(i){
        const t=enThemes[i%enThemes.length];
        return [
          `Today is designed for ${t[0]} and ${t[1]}.`,
          `Keep your pace calm: ${t[2]}, then commit to ${t[3]} and stop.`,
          `If pressure appears, choose a slow reset—${t[4]} helps your mind return to clarity.`,
          `Avoid drama and avoid forcing outcomes; your best power today is quiet stability.`,
          `End the day by protecting your peace and giving warmth to the people close to you.`
        ].join(' ');
      }
      function zhText(i){
        const t=zhThemes[i%zhThemes.length];
        return [
          `今天更适合${t[0]}与${t[1]}，把节奏放慢。`,
          `先保持${t[2]}，只做${t[3]}，完成后就停下来。`,
          `如果压力上来，用一个温柔的重启：${t[4]}会让心回到清晰。`,
          `避免纷争，也别强推结果；你今天的力量来自安静的稳定。`,
          `把温暖留给亲近的人，守住边界，你的福流会自然回应。`
        ].join('');
      }

      const EN=[...Array(100)].map((_,i)=>enText(i));
      const ZH=[...Array(100)].map((_,i)=>zhText(i));
      return {EN, ZH};
    }
    const P = buildPredictions();

    function getPrediction(){
      const total=100;
      const id = State.nextId(total);
      const lang = I18N.get();
      return (lang==='en') ? P.EN[id] : P.ZH[id];
    }

    /* =======================
       6) PARCHMENT (brush write + falling stamp + gold dust)
    ======================= */
    const Overlay = (function(){
      const overlay=document.getElementById('overlay');
      const close=document.getElementById('closeOverlay');
      const paper=document.getElementById('paper');
      const ctx=paper.getContext('2d');

      function show(){ overlay.classList.add('show'); resize(); }
      function hide(){ overlay.classList.remove('show'); }
      close.addEventListener('click', hide);

      function resize(){
        const dpr=PERF.dprCap();
        const r=paper.getBoundingClientRect();
        paper.width = Math.floor(r.width*dpr);
        paper.height = Math.floor(r.height*dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      window.addEventListener('resize', resize);

      function parchmentBG(w,h){
        ctx.clearRect(0,0,w,h);
        const g=ctx.createLinearGradient(0,0,w,h);
        g.addColorStop(0,'rgba(230,200,145,0.18)');
        g.addColorStop(0.35,'rgba(150,115,70,0.22)');
        g.addColorStop(1,'rgba(70,50,30,0.32)');
        ctx.fillStyle=g;
        ctx.fillRect(0,0,w,h);

        ctx.save();
        ctx.globalCompositeOperation='multiply';
        const v=ctx.createRadialGradient(w*0.5,h*0.45,30,w*0.5,h*0.45,Math.max(w,h)*0.75);
        v.addColorStop(0,'rgba(0,0,0,0)');
        v.addColorStop(1,'rgba(0,0,0,0.78)');
        ctx.fillStyle=v;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalAlpha=0.10;
        for(let i=0;i<150;i++){
          const y=Math.random()*h;
          ctx.strokeStyle='rgba(255,243,209,0.16)';
          ctx.lineWidth=1;
          ctx.beginPath();
          ctx.moveTo(0,y);
          ctx.lineTo(w,y+(Math.random()*8-4));
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawHeader(){
        ctx.save();
        ctx.fillStyle='rgba(255,243,209,0.88)';
        ctx.font='800 14px Inter, system-ui';
        ctx.fillText(I18N.get()==='zh' ? '天宫指引' : 'TEMPLE GUIDANCE', 26, 34);
        ctx.restore();
      }

      function wrapText(text, maxW, font){
        ctx.font=font;
        const isZH = I18N.get()==='zh';
        const tokens = isZH ? text.split('') : text.split(' ');
        const lines=[];
        let line='';
        for(let i=0;i<tokens.length;i++){
          const t = isZH ? tokens[i] : (tokens[i]+' ');
          const test=line+t;
          if(ctx.measureText(test).width>maxW && line.length){
            lines.push(line);
            line=t;
          }else line=test;
        }
        if(line.trim().length) lines.push(line);
        return lines;
      }

      // gold dust particles for overlay
      const dust=[];
      function dustBurst(cx,cy){
        const n = (PERF.quality==='low')?22:(PERF.quality==='med'?34:46);
        for(let i=0;i<n;i++){
          dust.push({
            x:cx,y:cy,
            vx:(Math.random()*2-1)*2.4,
            vy:(Math.random()*-1)*3.2 - 1.0,
            r:0.8+Math.random()*2.2,
            a:0.65+Math.random()*0.25,
            life: 0.9+Math.random()*0.6
          });
        }
      }
      function stepDust(dt){
        for(let i=dust.length-1;i>=0;i--){
          const p=dust[i];
          p.life -= dt;
          p.x += p.vx*dt*60;
          p.y += p.vy*dt*60;
          p.vy += 0.06*dt*60;
          p.a *= 0.97;
          if(p.life<=0 || p.a<0.02) dust.splice(i,1);
        }
      }
      function drawDust(){
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        for(const p of dust){
          ctx.fillStyle = 'rgba(255,211,106,'+Math.max(0,p.a)+')';
          ctx.shadowColor='rgba(255,211,106,0.35)';
          ctx.shadowBlur=14;
          ctx.beginPath();
          ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawSeal(x,y,scale){
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(-0.07);
        ctx.scale(scale,scale);
        ctx.fillStyle='rgba(184,0,29,0.92)';
        ctx.strokeStyle='rgba(255,211,106,0.22)';
        ctx.lineWidth=2;
        ctx.shadowColor='rgba(0,0,0,0.35)';
        ctx.shadowBlur=14;
        const s=96;
        ctx.fillRect(-s/2,-s/2,s,s);
        ctx.strokeRect(-s/2,-s/2,s,s);
        ctx.shadowBlur=0;
        ctx.fillStyle='rgba(255,243,209,0.92)';
        ctx.font='800 44px serif';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText('财', 0, 4);
        ctx.restore();
      }

      async function play(text){
        AudioX.ensure();
        show();

        const w=paper.getBoundingClientRect().width;
        const h=paper.getBoundingClientRect().height;

        const padX=34;
        const topY=76;
        const maxW=w-padX*2;

        const font = (I18N.get()==='zh')
          ? "700 18px 'PingFang SC','Noto Sans SC','Microsoft YaHei',serif"
          : "700 17px Georgia, 'Times New Roman', serif";

        const lines = wrapText(text, maxW, font);

        parchmentBG(w,h);
        drawHeader();

        // write “brush”
        ctx.textBaseline='top';
        ctx.font=font;

        AudioX.whoosh();

        let y=topY;
        let count=0;
        for(let li=0; li<lines.length; li++){
          const L=lines[li];
          let x=padX;
          for(let ci=0; ci<L.length; ci++){
            const ch=L[ci];

            const jx=(Math.random()*0.6-0.3);
            const jy=(Math.random()*0.6-0.3);

            const ink=ctx.createLinearGradient(x,y,x,y+22);
            ink.addColorStop(0,'rgba(255,243,209,0.92)');
            ink.addColorStop(1,'rgba(255,211,106,0.72)');
            ctx.fillStyle=ink;

            ctx.fillText(ch, x+jx, y+jy);

            x += ctx.measureText(ch).width;
            count++;
            if(count%14===0) AudioX.tick();
            await new Promise(r=>setTimeout(r, 10));
          }
          y+=26;
          if(y>h-150) break;
        }

        // footer
        ctx.save();
        ctx.fillStyle='rgba(255,211,106,0.70)';
        ctx.font='600 12px Inter, system-ui';
        const ts=new Date().toLocaleString(I18N.get()==='zh'?'zh-CN':'en-US');
        ctx.fillText(ts, padX, h-42);
        ctx.restore();

        // falling stamp
        await new Promise(r=>setTimeout(r, 250));
        AudioX.stamp();
        haptic();

        const sx=w-112, sy=h-122;
        const startY = -80;
        const endY = sy;

        let last=performance.now();
        let t=0;
        while(t<1){
          const now=performance.now();
          const dt=(now-last)/1000; last=now;
          t = Math.min(1, t + dt*2.4);
          const ease = 1 - Math.pow(1-t, 3);

          // redraw bg + final text fast
          parchmentBG(w,h);
          drawHeader();
          ctx.save();
          ctx.font=font;
          ctx.fillStyle='rgba(255,243,209,0.92)';
          ctx.textBaseline='top';
          let yy=topY;
          for(let li=0; li<lines.length; li++){
            ctx.fillText(lines[li], padX, yy);
            yy+=26; if(yy>h-150) break;
          }
          ctx.restore();

          ctx.save();
          ctx.fillStyle='rgba(255,211,106,0.70)';
          ctx.font='600 12px Inter, system-ui';
          ctx.fillText(ts, padX, h-42);
          ctx.restore();

          // stamp position (drop)
          const py = startY + (endY-startY)*ease;
          const sc = 0.55 + 0.50*ease;
          drawSeal(sx, py, sc);

          // dust on impact
          if(t>0.92 && t<0.98) dustBurst(sx, sy);

          stepDust(dt);
          drawDust();

          await new Promise(r=>requestAnimationFrame(r));
        }

        // final dust settle
        let settle=0.35;
        let last2=performance.now();
        while(settle>0 && dust.length){
          const now=performance.now();
          const dt=(now-last2)/1000; last2=now;
          settle-=dt;
          parchmentBG(w,h);
          drawHeader();
          ctx.save();
          ctx.font=font;
          ctx.fillStyle='rgba(255,243,209,0.92)';
          ctx.textBaseline='top';
          let yy=topY;
          for(let li=0; li<lines.length; li++){
            ctx.fillText(lines[li], padX, yy);
            yy+=26; if(yy>h-150) break;
          }
          ctx.restore();
          ctx.save();
          ctx.fillStyle='rgba(255,211,106,0.70)';
          ctx.font='600 12px Inter, system-ui';
          ctx.fillText(ts, padX, h-42);
          ctx.restore();
          drawSeal(sx, sy, 1.0);
          stepDust(dt);
          drawDust();
          await new Promise(r=>requestAnimationFrame(r));
        }
      }

      return {play, hide};
    })();

    /* =======================
       7) FX 2D (background dust shimmer)
    ======================= */
    const fx2d = document.getElementById('fx2d');
    const fx = fx2d.getContext('2d');
    function resizeFX(){
      const dpr=PERF.dprCap();
      fx2d.width=Math.floor(innerWidth*dpr);
      fx2d.height=Math.floor(innerHeight*dpr);
      fx2d.style.width=innerWidth+'px';
      fx2d.style.height=innerHeight+'px';
      fx.setTransform(dpr,0,0,dpr,0,0);
    }
    resizeFX();
    addEventListener('resize', resizeFX);

    const bgDust = [];
    function initBGDust(){
      bgDust.length=0;
      const n = (PERF.quality==='low')?70:(PERF.quality==='med'?110:140);
      for(let i=0;i<n;i++){
        bgDust.push({
          x:Math.random()*innerWidth,
          y:Math.random()*innerHeight,
          r:0.6+Math.random()*2.2,
          a:0.06+Math.random()*0.22,
          s:0.15+Math.random()*0.5
        });
      }
    }
    initBGDust();

    function drawBGDust(dt){
      fx.clearRect(0,0,innerWidth,innerHeight);
      fx.save();
      fx.globalCompositeOperation='lighter';
      for(const p of bgDust){
        p.y -= p.s*dt*60;
        if(p.y<-10){ p.y=innerHeight+10; p.x=Math.random()*innerWidth; }
        const tw = 0.7 + 0.3*Math.sin((performance.now()*0.002)+p.x*0.01);
        fx.fillStyle='rgba(255,211,106,'+(p.a*tw)+')';
        fx.shadowColor='rgba(255,211,106,0.22)';
        fx.shadowBlur=12;
        fx.beginPath();
        fx.arc(p.x,p.y,p.r,0,Math.PI*2);
        fx.fill();
      }
      fx.restore();
    }

    /* =======================
       8) THREE SCENE (mobile-first composition)
       - Orthographic camera for exact framing on phones
       - Dragon top full width
       - Wheel center, never cropped
       - Stars + comets
    ======================= */
    const canvas = document.getElementById('stage3d');

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(PERF.dprCap());
    renderer.setSize(innerWidth, innerHeight, false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();

    // Ortho camera for stable UI-like game framing
    const cam = new THREE.OrthographicCamera(-1,1,1,-1, 0.1, 100);
    cam.position.set(0,0,10);
    cam.lookAt(0,0,0);

    // Light
    const ambient = new THREE.AmbientLight(0xffffff, 0.95);
    scene.add(ambient);

    // Helpers for sizing in NDC-like world space
    function computeLayout(){
      const w=innerWidth, h=innerHeight;
      const aspect = w/h;

      // Ortho bounds in "world units" = height based
      // We set vertical size = 2, horizontal = 2*aspect
      cam.left   = -aspect;
      cam.right  =  aspect;
      cam.top    =  1;
      cam.bottom = -1;
      cam.updateProjectionMatrix();

      // Mobile-first wheel size in world units:
      // Wheel diameter maps to ~72% of min(vw,vh)
      // In our ortho space height is 2 units -> 100% height
      const wheelFrac = 0.72; // of min dimension
      const minFrac = Math.min(1, aspect); // relative to height
      const wheelDiam = 2 * wheelFrac * (minFrac); // 0..2
      return {aspect, wheelDiam};
    }

    /* ---- Stars field (Points) ---- */
    function makeStars(count){
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count*3);
      const col = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        // distribute in a box behind
        const x = (Math.random()*2-1) * 8;
        const y = (Math.random()*2-1) * 4.5;
        const z = -Math.random()*8;
        pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;

        const warm = Math.random()<0.35;
        const c = warm ? new THREE.Color(0xFFD36A) : new THREE.Color(0xCFE8FF);
        const k = warm ? (0.55+Math.random()*0.45) : (0.45+Math.random()*0.55);
        col[i*3+0]=c.r*k; col[i*3+1]=c.g*k; col[i*3+2]=c.b*k;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geo.setAttribute('color', new THREE.BufferAttribute(col,3));
      const mat = new THREE.PointsMaterial({
        size: (PERF.quality==='low')?0.020:(PERF.quality==='med'?0.018:0.016),
        vertexColors:true,
        transparent:true,
        opacity:0.95,
        depthWrite:false
      });
      return new THREE.Points(geo, mat);
    }
    const starCount = (PERF.quality==='low')?1800:(PERF.quality==='med'?2800:3800);
    const stars = makeStars(starCount);
    scene.add(stars);

    /* ---- Comets (instanced quads) ---- */
    const cometN = (PERF.quality==='low')?6:(PERF.quality==='med'?9:12);
    const cometGeo = new THREE.PlaneGeometry(0.55, 0.06);
    const cometMat = new THREE.MeshBasicMaterial({color:0xFFD36A, transparent:true, opacity:0.55});
    const comets=[];
    for(let i=0;i<cometN;i++){
      const m=new THREE.Mesh(cometGeo, cometMat.clone());
      m.material.opacity = 0.22 + Math.random()*0.45;
      m.position.set((Math.random()*2-1)*6, (Math.random()*2-1)*3, -1 - Math.random()*6);
      m.rotation.z = -0.4 + Math.random()*0.8;
      m.scale.setScalar(0.6 + Math.random()*1.6);
      comets.push(m);
      scene.add(m);
    }

    /* ---- Dragon billboard (always visible) ---- */
    const dragonGroup = new THREE.Group();
    scene.add(dragonGroup);

    const dragonPlane = new THREE.PlaneGeometry(2.0, 1.15); // will be scaled on resize
    const dragonMat = new THREE.ShaderMaterial({
      transparent:true,
      uniforms:{
        uTex:{value:null},
        uTime:{value:0},
        uGlow:{value:0.65},
        uHasTex:{value:0}
      },
      vertexShader: `
        varying vec2 vUv;
        uniform float uTime;
        void main(){
          vUv=uv;
          vec3 p=position;
          float w=sin(uTime*1.4 + p.x*2.2)*0.015;
          p.y += w;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform sampler2D uTex;
        uniform float uTime;
        uniform float uGlow;
        uniform float uHasTex;

        float softCircle(vec2 uv, vec2 c, float r, float blur){
          float d = length(uv-c);
          return smoothstep(r, r-blur, d);
        }

        void main(){
          vec3 gold = vec3(1.0, 0.83, 0.42);
          float pulse = 0.55 + 0.45*sin(uTime*1.2);

          vec4 tex = vec4(0.0);
          if(uHasTex > 0.5){
            tex = texture2D(uTex, vUv);
          }

          // If texture exists -> use it, else -> procedural aura silhouette
          vec3 baseCol = tex.rgb;
          float a = (uHasTex > 0.5) ? 0.95 : 1.0;

          if(uHasTex < 0.5){
            // procedural "dragon aura": layered soft circles + noise-like bands
            float m1 = softCircle(vUv, vec2(0.52,0.55), 0.42, 0.20);
            float m2 = softCircle(vUv, vec2(0.42,0.62), 0.30, 0.18);
            float m3 = softCircle(vUv, vec2(0.62,0.46), 0.26, 0.16);
            float band = 0.5 + 0.5*sin((vUv.y*8.0) + uTime*2.0);
            float mask = clamp((m1+m2+m3)*0.85, 0.0, 1.0) * (0.55 + 0.45*band);
            baseCol = gold * (0.25 + 0.75*mask);
            a = mask;
          }

          // edge glow
          float edge = smoothstep(0.0,0.12,vUv.x)*smoothstep(0.0,0.12,vUv.y)*smoothstep(0.0,0.12,1.0-vUv.x)*smoothstep(0.0,0.12,1.0-vUv.y);
          vec3 glow = gold * (uGlow*(0.35+0.65*pulse)) * (1.0-edge);

          vec3 col = baseCol + glow*0.9;
          col *= 0.92;

          gl_FragColor = vec4(col, a);
        }
      `
    });
    const dragonMesh = new THREE.Mesh(dragonPlane, dragonMat);
    dragonGroup.add(dragonMesh);

    /* ---- Wheel (3D disk + ring + inner sheen) ---- */
    const wheelGroup = new THREE.Group();
    scene.add(wheelGroup);

    const wheelOuterGeo = new THREE.RingGeometry(0.52, 0.66, 128);
    const wheelOuterMat = new THREE.MeshBasicMaterial({color:0xFFD36A, transparent:true, opacity:0.95});
    const wheelOuter = new THREE.Mesh(wheelOuterGeo, wheelOuterMat);
    wheelGroup.add(wheelOuter);

    const wheelInnerGeo = new THREE.CircleGeometry(0.50, 128);
    const wheelInnerMat = new THREE.MeshBasicMaterial({color:0xB8001D, transparent:true, opacity:0.98});
    const wheelInner = new THREE.Mesh(wheelInnerGeo, wheelInnerMat);
    wheelGroup.add(wheelInner);

    // glossy highlight overlay
    const glossGeo = new THREE.CircleGeometry(0.50, 128);
    const glossMat = new THREE.ShaderMaterial({
      transparent:true,
      uniforms:{uTime:{value:0}},
      vertexShader:`varying vec2 vUv; void main(){vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
      fragmentShader:`
        varying vec2 vUv;
        uniform float uTime;
        void main(){
          vec2 uv=vUv;
          float hl = smoothstep(0.55, 0.05, distance(uv, vec2(0.5,0.78)));
          hl *= 0.55 + 0.45*sin(uTime*1.1);
          vec3 col = vec3(1.0,0.92,0.70)*hl;
          gl_FragColor = vec4(col, hl*0.45);
        }
      `
    });
    const gloss = new THREE.Mesh(glossGeo, glossMat);
    gloss.position.z = 0.01;
    wheelGroup.add(gloss);

    /* ---- Resize/layout apply ---- */
    function applyLayout(){
      const L=computeLayout();

      renderer.setPixelRatio(PERF.dprCap());
      renderer.setSize(innerWidth, innerHeight, false);

      // place dragon top — full width edge-to-edge
      // In ortho, full width = 2*aspect units. We'll occupy ~95% width.
      const aspect=L.aspect;
      const fullW = 2*aspect;
      const dragonW = fullW*0.95;
      const dragonH = dragonW*(1.15/2.0); // keep plane ratio (2.0 x 1.15)
      dragonMesh.scale.set(dragonW/2.0, dragonH/1.15, 1); // plane base size 2x1.15
      dragonGroup.position.set(0, 0.62, -0.6); // top area

      // wheel center — never cropped
      const wheelDiam = L.wheelDiam;
      const wheelScale = wheelDiam; // wheel created around radius ~0.66
      wheelGroup.scale.setScalar(wheelScale);
      wheelGroup.position.set(0, -0.12, 0);

      // stars framing
      stars.position.z = -6;

      // keep comets within view
      for(const c of comets){
        // ensure inside bounds after resize
        if(Math.abs(c.position.x) > (aspect*1.2)) c.position.x *= 0.6;
      }
    }
    applyLayout();
    addEventListener('resize', applyLayout);

    /* ---- Texture load (dragon.jpg) ---- */
    const loader = new THREE.TextureLoader();
    loader.load(
      './dragon.jpg',
      (tex)=>{
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        dragonMat.uniforms.uTex.value = tex;
        dragonMat.uniforms.uHasTex.value = 1;
      },
      undefined,
      (err)=>{
        // fallback stays procedural
        dragonMat.uniforms.uHasTex.value = 0;
      }
    );

    /* =======================
       9) INPUT (tilt parallax, mobile-first)
    ======================= */
    let tx=0, ty=0, cx=0, cy=0;
    function onMove(nx,ny){
      tx = (nx/innerWidth)*2 - 1;
      ty = (ny/innerHeight)*2 - 1;
    }
    addEventListener('mousemove', (e)=>onMove(e.clientX, e.clientY), {passive:true});
    addEventListener('touchmove', (e)=>{
      const t=e.touches && e.touches[0]; if(!t) return;
      onMove(t.clientX, t.clientY);
    }, {passive:true});

    // device tilt (optional)
    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
    if(window.DeviceOrientationEvent){
      addEventListener('deviceorientation', (e)=>{
        // gamma: left/right, beta: front/back
        const g = clamp((e.gamma||0)/45, -1, 1);
        const b = clamp((e.beta||0)/45, -1, 1);
        tx = g;
        ty = b;
      }, {passive:true});
    }

    /* =======================
       10) SPIN / WISH MOMENT (simple but “game feel”)
    ======================= */
    let spinning=false;
    let spinVel=0;
    let spinGlow=0;
    let wishFlash=0;

    function startSpin(){
      if(spinning) return;
      AudioX.ensure();

      if(State.spunToday() && !State.premiumOn()){
        Overlay.play(I18N.get()==='zh'
          ? '今日已转轮。保持节制，明日再来。若需要更多指引，可通过供奉开启尊享。'
          : 'You already spun today. Keep discipline and return tomorrow. If you need more guidance, unlock Premium via the Gate.'
        );
        return;
      }

      spinning=true;
      spinVel = 0.42 + Math.random()*0.55;
      spinGlow = 1.0;
      AudioX.whoosh();
      haptic();

      // rewards
      const gain = 3 + ((Math.random()*10)|0);
      State.addQK(gain);
      State.setFlow(State.get().flow + (Math.random()*10-4));
      State.markSpin();
      renderHUD();

      setTimeout(async ()=>{
        const text=getPrediction();
        AudioX.chime();
        await new Promise(r=>setTimeout(r, 240));
        Overlay.play(text);
        spinning=false;
      }, 1100);
    }

    function wishMoment(){
      AudioX.ensure();
      wishFlash=1.0;
      AudioX.chime();
      Overlay.play(I18N.get()==='zh'
        ? '许一个愿。保持安静，听见内心。今天只做一件重要的事，然后好好休息。让福流自然到来。'
        : 'Make a wish. Stay quiet and listen within. Do one meaningful thing today, then rest deeply. Let your flow arrive naturally.'
      );
    }

    /* =======================
       11) UI EVENTS
    ======================= */
    document.getElementById('spinBtn').addEventListener('click', startSpin);
    document.getElementById('wishBtn').addEventListener('click', wishMoment);

    document.getElementById('langBtn').addEventListener('click', ()=>{
      I18N.toggle(); // EN label stays EN
    });

    document.getElementById('helpBtn').addEventListener('click', ()=>{
      AudioX.ensure(); AudioX.chime();
      Overlay.play(I18N.get()==='zh'
        ? '三步：转轮 → 得到指引 → 做出选择。保持平静，守住节奏。'
        : 'Three steps: Spin → Guidance → Decision. Keep calm and protect your rhythm.'
      );
    });

    document.getElementById('gateBtn').addEventListener('click', ()=>{
      // stub premium: 24h
      AudioX.ensure(); AudioX.chime();
      State.addPremium(24);
      Overlay.play(I18N.get()==='zh'
        ? '供奉已记录。接下来 24 小时为「尊享」状态。保持温柔与自律，福流会回应你。'
        : 'Offering recorded. Premium is active for 24 hours. Stay calm and disciplined, and your flow will respond.'
      );
    });

    document.getElementById('soundBtn').addEventListener('click', ()=>{
      AudioX.ensure();
      const on = AudioX.toggle();
      document.getElementById('soundBtn').textContent = on ? 'S' : '×';
    });

    /* =======================
       12) MAIN LOOP
    ======================= */
    const clock = new THREE.Clock();

    function tick(){
      requestAnimationFrame(tick);
      const dt = Math.min(0.033, clock.getDelta());
      const t = clock.elapsedTime;

      // parallax smoothing
      cx += (tx - cx)*0.06;
      cy += (ty - cy)*0.06;

      // subtle camera drift (ortho): we shift groups instead of camera
      dragonGroup.position.x = cx * 0.10;
      dragonGroup.position.y = 0.62 + (-cy)*0.06;

      wheelGroup.position.x = cx * 0.08;
      wheelGroup.position.y = -0.12 + (-cy)*0.06;

      // stars drift
      stars.rotation.z += dt*0.02;

      // comets fly like video
      for(const c of comets){
        c.position.x += dt* (0.8 + Math.random()*0.2);
        c.position.y -= dt* (0.20 + Math.random()*0.05);
        if(c.position.x > (cam.right + 1.5)){
          c.position.x = cam.left - 1.5;
          c.position.y = (Math.random()*2-1)*0.9;
        }
      }

      // wheel spin
      if(spinVel>0.0005){
        wheelGroup.rotation.z += spinVel;
        spinVel *= 0.965;
      }

      // glow pulse on spin
      spinGlow *= 0.94;
      wheelOuterMat.opacity = 0.90 + 0.10*Math.sin(t*2.2) + spinGlow*0.08;
      glossMat.uniforms.uTime.value = t;

      // dragon aura
      dragonMat.uniforms.uTime.value = t;
      dragonMat.uniforms.uGlow.value = 0.62 + 0.18*Math.sin(t*1.1) + spinGlow*0.15;

      // wish flash (screen feel) via 2d overlay
      wishFlash *= 0.92;

      // background dust
      drawBGDust(dt);

      // flash overlay
      if(wishFlash>0.02){
        fx.save();
        fx.globalCompositeOperation='screen';
        fx.fillStyle='rgba(255,211,106,'+(wishFlash*0.10)+')';
        fx.fillRect(0,0,innerWidth,innerHeight);
        fx.restore();
      }

      renderer.render(scene, cam);
    }
    tick();

  })();
  </script>
</body>
</html>
